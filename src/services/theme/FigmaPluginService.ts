/**
 * Figma Plugin Service
 * XStudio 토큰을 Figma Plugin으로 Export
 */

import type { DesignToken, ColorValueHSL } from '../../types/theme/token.types';
import { hslToRgb } from '../../utils/theme/colorUtils';

export interface FigmaPluginExportOptions {
  /**
   * Plugin 이름
   */
  pluginName: string;

  /**
   * Plugin 설명
   */
  description?: string;

  /**
   * 생성할 파일 타입
   */
  includeFiles: {
    manifest?: boolean; // manifest.json
    code?: boolean; // code.ts (plugin logic)
    ui?: boolean; // ui.html (plugin UI)
  };

  /**
   * Export 대상
   */
  exportTargets: {
    colors?: boolean;
    textStyles?: boolean;
    effects?: boolean;
  };
}

export interface FigmaPluginExportResult {
  files: {
    'manifest.json'?: string;
    'code.ts'?: string;
    'ui.html'?: string;
  };
  metadata: {
    pluginName: string;
    tokenCount: number;
    generatedAt: string;
  };
}

/**
 * Figma Plugin Export 서비스
 */
export class FigmaPluginService {
  /**
   * XStudio 토큰을 Figma Plugin 파일로 변환
   */
  static async exportToFigmaPlugin(
    tokens: DesignToken[],
    options: FigmaPluginExportOptions
  ): Promise<FigmaPluginExportResult> {
    const files: FigmaPluginExportResult['files'] = {};

    // 1. manifest.json 생성
    if (options.includeFiles.manifest !== false) {
      files['manifest.json'] = this.generateManifest(options);
    }

    // 2. code.ts (plugin 로직) 생성
    if (options.includeFiles.code !== false) {
      files['code.ts'] = this.generateCode(tokens, options);
    }

    // 3. ui.html (plugin UI) 생성
    if (options.includeFiles.ui !== false) {
      files['ui.html'] = this.generateUI(options);
    }

    return {
      files,
      metadata: {
        pluginName: options.pluginName,
        tokenCount: tokens.length,
        generatedAt: new Date().toISOString(),
      },
    };
  }

  /**
   * manifest.json 생성
   */
  private static generateManifest(options: FigmaPluginExportOptions): string {
    const manifest = {
      name: options.pluginName,
      id: this.generatePluginId(options.pluginName),
      api: '1.0.0',
      main: 'code.js',
      ui: 'ui.html',
      editorType: ['figma'],
      capabilities: ['write'],
      description: options.description || 'Import design tokens from XStudio',
    };

    return JSON.stringify(manifest, null, 2);
  }

  /**
   * code.ts (plugin 로직) 생성
   */
  private static generateCode(
    tokens: DesignToken[],
    options: FigmaPluginExportOptions
  ): string {
    const colorTokens = tokens.filter((t) => t.type === 'color');
    const typographyTokens = tokens.filter((t) => t.type === 'typography');
    const shadowTokens = tokens.filter((t) => t.type === 'shadow');

    const lines: string[] = [];

    // Header
    lines.push('/**');
    lines.push(` * ${options.pluginName}`);
    lines.push(` * Generated by XStudio - ${new Date().toISOString()}`);
    lines.push(' */');
    lines.push('');

    // Show UI
    lines.push('figma.showUI(__html__, { width: 400, height: 600 });');
    lines.push('');

    // Message Handler
    lines.push('figma.ui.onmessage = async (msg) => {');
    lines.push('  if (msg.type === "import-tokens") {');
    lines.push('    try {');
    lines.push('      let imported = 0;');
    lines.push('');

    // Import Colors
    if (options.exportTargets.colors && colorTokens.length > 0) {
      lines.push('      // Import Color Styles');
      lines.push('      const colorTokens = msg.tokens.filter((t: any) => t.type === "color");');
      lines.push('      for (const token of colorTokens) {');
      lines.push('        const style = figma.createPaintStyle();');
      lines.push('        style.name = token.name;');
      lines.push('        style.paints = [{');
      lines.push('          type: "SOLID",');
      lines.push('          color: {');
      lines.push('            r: token.value.r / 255,');
      lines.push('            g: token.value.g / 255,');
      lines.push('            b: token.value.b / 255,');
      lines.push('          },');
      lines.push('          opacity: token.value.a || 1,');
      lines.push('        }];');
      lines.push('        imported++;');
      lines.push('      }');
      lines.push('');
    }

    // Import Text Styles
    if (options.exportTargets.textStyles && typographyTokens.length > 0) {
      lines.push('      // Import Text Styles');
      lines.push('      const textTokens = msg.tokens.filter((t: any) => t.type === "typography");');
      lines.push('      for (const token of textTokens) {');
      lines.push('        const style = figma.createTextStyle();');
      lines.push('        style.name = token.name;');
      lines.push('        if (token.value.fontSize) {');
      lines.push('          style.fontSize = parseFloat(token.value.fontSize);');
      lines.push('        }');
      lines.push('        if (token.value.fontWeight) {');
      lines.push('          style.fontName = {');
      lines.push('            family: token.value.fontFamily || "Inter",');
      lines.push('            style: token.value.fontWeight,');
      lines.push('          };');
      lines.push('        }');
      lines.push('        if (token.value.lineHeight) {');
      lines.push('          style.lineHeight = { value: parseFloat(token.value.lineHeight), unit: "PIXELS" };');
      lines.push('        }');
      lines.push('        imported++;');
      lines.push('      }');
      lines.push('');
    }

    // Import Effects (Shadows)
    if (options.exportTargets.effects && shadowTokens.length > 0) {
      lines.push('      // Import Effect Styles (Shadows)');
      lines.push('      const shadowTokens = msg.tokens.filter((t: any) => t.type === "shadow");');
      lines.push('      for (const token of shadowTokens) {');
      lines.push('        const style = figma.createEffectStyle();');
      lines.push('        style.name = token.name;');
      lines.push('        style.effects = [{');
      lines.push('          type: "DROP_SHADOW",');
      lines.push('          color: token.value.color,');
      lines.push('          offset: { x: token.value.offsetX || 0, y: token.value.offsetY || 0 },');
      lines.push('          radius: token.value.blur || 0,');
      lines.push('          spread: token.value.spread || 0,');
      lines.push('          visible: true,');
      lines.push('          blendMode: "NORMAL",');
      lines.push('        }];');
      lines.push('        imported++;');
      lines.push('      }');
      lines.push('');
    }

    // Close
    lines.push('      figma.ui.postMessage({');
    lines.push('        type: "import-complete",');
    lines.push('        imported,');
    lines.push('      });');
    lines.push('    } catch (error) {');
    lines.push('      figma.ui.postMessage({');
    lines.push('        type: "import-error",');
    lines.push('        message: error.message,');
    lines.push('      });');
    lines.push('    }');
    lines.push('  }');
    lines.push('');
    lines.push('  if (msg.type === "close-plugin") {');
    lines.push('    figma.closePlugin();');
    lines.push('  }');
    lines.push('};');

    return lines.join('\n');
  }

  /**
   * ui.html (plugin UI) 생성
   */
  private static generateUI(options: FigmaPluginExportOptions): string {
    const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${options.pluginName}</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Inter, sans-serif;
      font-size: 14px;
      padding: 16px;
      background: #ffffff;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    p {
      color: #666;
      margin-bottom: 20px;
      line-height: 1.5;
    }

    .token-list {
      max-height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
      padding: 12px;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .token-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: white;
      border-radius: 4px;
      margin-bottom: 4px;
    }

    .token-color {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }

    .token-name {
      font-family: monospace;
      font-size: 12px;
    }

    .button-group {
      display: flex;
      gap: 8px;
    }

    button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 200ms;
    }

    .primary-btn {
      background: #0d99ff;
      color: white;
    }

    .primary-btn:hover {
      background: #0b7fdd;
    }

    .secondary-btn {
      background: #f0f0f0;
      color: #333;
    }

    .secondary-btn:hover {
      background: #e0e0e0;
    }

    .status {
      margin-top: 12px;
      padding: 12px;
      border-radius: 6px;
      font-size: 13px;
    }

    .success {
      background: #e7f7ed;
      color: #0f7b3f;
    }

    .error {
      background: #ffe7e7;
      color: #c92a2a;
    }
  </style>
</head>
<body>
  <h1>${options.pluginName}</h1>
  <p>${options.description || 'Import design tokens from XStudio to Figma'}</p>

  <div id="token-list" class="token-list">
    <p>Loading tokens...</p>
  </div>

  <div class="button-group">
    <button class="primary-btn" onclick="importTokens()">Import to Figma</button>
    <button class="secondary-btn" onclick="closePlugin()">Cancel</button>
  </div>

  <div id="status"></div>

  <script>
    // Token data (will be replaced by actual tokens)
    const TOKENS = ${JSON.stringify(
      tokens.map((t) => {
        if (t.type === 'color' && typeof t.value === 'object') {
          const rgb = hslToRgb(t.value as ColorValueHSL);
          return {
            ...t,
            value: rgb,
          };
        }
        return t;
      }),
      null,
      2
    )};

    // Render token list
    function renderTokens() {
      const list = document.getElementById('token-list');
      list.innerHTML = TOKENS.map(token => {
        if (token.type === 'color') {
          return \`
            <div class="token-item">
              <div class="token-color" style="background: rgb(\${token.value.r}, \${token.value.g}, \${token.value.b})"></div>
              <span class="token-name">\${token.name}</span>
            </div>
          \`;
        }
        return \`
          <div class="token-item">
            <span class="token-name">\${token.name}</span>
          </div>
        \`;
      }).join('');
    }

    // Import tokens
    function importTokens() {
      parent.postMessage({
        pluginMessage: {
          type: 'import-tokens',
          tokens: TOKENS,
        }
      }, '*');
    }

    // Close plugin
    function closePlugin() {
      parent.postMessage({
        pluginMessage: { type: 'close-plugin' }
      }, '*');
    }

    // Listen for messages from plugin
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      const status = document.getElementById('status');

      if (msg.type === 'import-complete') {
        status.className = 'status success';
        status.textContent = \`✅ Successfully imported \${msg.imported} styles!\`;
        setTimeout(() => {
          closePlugin();
        }, 2000);
      }

      if (msg.type === 'import-error') {
        status.className = 'status error';
        status.textContent = \`⚠️ Error: \${msg.message}\`;
      }
    };

    // Initialize
    renderTokens();
  </script>
</body>
</html>`;

    return html;
  }

  /**
   * Plugin ID 생성 (name 기반 hash)
   */
  private static generatePluginId(name: string): string {
    // Simple hash function for plugin ID
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      const char = name.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString();
  }

  /**
   * Plugin 파일 다운로드 (zip)
   */
  static async downloadPluginFiles(result: FigmaPluginExportResult): Promise<void> {
    // Note: In a real implementation, this would create a .zip file
    // For now, we'll download each file separately

    for (const [filename, content] of Object.entries(result.files)) {
      if (!content) continue;

      const blob = new Blob([content], {
        type: filename.endsWith('.html') ? 'text/html' : 'text/plain',
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      // Small delay between downloads
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
}

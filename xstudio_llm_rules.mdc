# xstudio Project LLM Rules

## Project Context
- **Framework**: React 19 SPA that uses React Router for navigation, React Aria Components for accessible widgets, and Zustand-powered builder tooling. Storybook 8 is configured for component-driven development.
- **Language**: TypeScript across `.ts` utility modules and `.tsx` React components with strict compiler options.
- **Build Tool**: Vite (React SWC plugin) orchestrates builds and dev server, backed by Tailwind CSS 4/PostCSS for styling and Vitest/Storybook tooling in development.

## Directory Structure Rules
```
src/
├── App.tsx / App.css        # Root shell and landing navigation
├── assets/                  # Static assets (e.g., react.svg)
├── auth/                    # Sign-in page, styles, and routing entry
├── builder/                 # Core visual builder (AI helpers, components, hooks, stores, theme, utils)
│   ├── ai/                  # Builder AI assistant UI and styles
│   ├── components/          # React Aria-based widget wrappers + CSS companions
│   ├── dataset/             # Sample data and seeds for the builder
│   ├── factories/           # ComponentFactory and related creation helpers
│   ├── monitor/, header/, overlay/, sidebar/, preview/ # Layout chrome around the builder workspace
│   ├── hooks/               # Complex builder hooks (element creation, iframe messaging, validation, etc.)
│   ├── inspector/           # Property inspectors and editors
│   ├── library/             # Component library panels and metadata
│   ├── main/                # BuilderCore, viewport, workspace entry points
│   ├── nodes/               # Node definitions/editors for tree-based UI
│   ├── stores/              # Zustand slices (elements, selection, theme, history) and helpers
│   ├── theme/               # Theme preview/editor surface
│   └── utils/               # Builder-only helpers (HierarchyManager, memory monitor, layout utils)
├── dashboard/               # Project dashboard page with Supabase-backed CRUD
├── demo/                    # Standalone demos (e.g., HistoryDemo.tsx)
├── env/                     # Environment-specific clients (Supabase singleton)
├── hooks/                   # App-wide hooks (e.g., useTheme)
├── services/api/            # Typed API service classes wrapping Supabase requests
├── stories/                 # Storybook stories and illustrative components/assets
├── types/                   # Shared domain models, props, events, supabase typings
├── utils/                   # Cross-cutting utilities (messaging, event engine, theming helpers)
├── index.css                # Tailwind base and global layer definitions
└── main.tsx / vite-env.d.ts # Application entry point and Vite typings
```

## Naming Conventions
- **Files**:
  - React components and Storybook stories use PascalCase (`BuilderHeader.tsx`, `ToggleButtonGroup.stories.tsx`).
  - Hooks are camelCase prefixed with `use` (`useElementCreator.ts`, `useTheme.ts`).
  - Zustand slices/utilities favour descriptive camelCase (`memoryMonitor.ts`, `elementUtils.ts`).
  - Routing entry points remain `index.tsx`/`index.ts` within feature folders.
  - CSS companions mirror the component name (`ComponentList.css`, `index.css`).
- **Components**: Declare components with `function ComponentName()` or `export const ComponentName = () => { ... }` and export them as default when representing a page/feature shell, otherwise as named exports.
- **Functions**: Use `camelCase` for helpers, callbacks, and hook return handlers (`handleAddElement`, `fetchProjects`).
- **Variables**: Prefer `camelCase`, reserve `PascalCase` for React components/types and uppercase for readonly constant maps only when semantically constant (`ComponentItem`).

## Code Style Guidelines
- **Indentation**: Default to 4-space indentation for TypeScript and JSX blocks, increasing by 4 spaces for nested JSX.
- **Quotes**: Favor single quotes in TypeScript/TSX logic; JSX attributes typically use double quotes per convention.
- **Semicolons**: Keep explicit semicolons at statement endings and exports to satisfy the ESLint configuration (bare CSS imports are the only common omission).
- **Formatting**: Group imports with external packages first, followed by blank line, then absolute/relative application modules. Co-locate related CSS imports directly beneath component imports.

## Import/Export Patterns
- External libraries (`react`, `react-router-dom`, `react-aria-components`, `zustand`, `lucide-react`) are imported before internal modules.
- Internal code relies on relative paths (`../`, `../../`); the `@/*` alias is reserved for future use—prefer relative imports today to mirror existing files.
- API communication happens through the service classes under `services/api`; UI or hooks consume those classes rather than calling Supabase directly.
- Shared types come from `src/types` and are imported via `import type` when the symbol is only used for typing to keep bundles lean.
- Export React components or helpers from barrel files (`builder/components/index.ts`) only when a directory already exposes grouped items; otherwise export directly from the module.

## Component Patterns
- Builder UI components wrap React Aria primitives and forward props, often applying project-specific class names (see `builder/components/Button.tsx`).
- Complex builder containers (`BuilderCore`, `BuilderWorkspace`, Inspector panels) orchestrate Zustand store selectors, React hooks (`useEffect`, `useCallback`) and service calls; keep side effects inside hooks and memoize callbacks that are passed downstream.
- Hooks inside `src/builder/hooks` encapsulate cross-cutting logic (element creation, iframe messaging, validation, theme coordination). Reuse them rather than duplicating store/service interactions.
- Props are strongly typed via interfaces from `src/types` (`ComponentElementProps`, `ElementEvent`). When introducing new elements, extend these shared types and wire defaults through `useElementCreator` and `ComponentFactory`.
- State management resides in the consolidated `useStore` Zustand store; derive selectors or action bundles via helper hooks (`useElementActions`, `useHistoryActions`). Avoid introducing new global state outside this pattern without discussion.

## Best Practices
- Use the Supabase client from `src/env/supabase.client.ts` and the API service layer for network operations; handle errors via `handleApiError` and the builder `useErrorHandler` hook to ensure consistent messaging and rollback support.
- Leverage the history and memory tooling (`historyManager`, `memoryMonitor`) when mutating builder state so undo/redo and performance diagnostics stay accurate.
- Keep Tailwind utility classes in JSX for layout scaffolding, but place builder-specific styling in adjacent CSS files to match the existing convention.
- When communicating with the preview iframe, route messages through `MessageService`/`useIframeMessenger` to maintain protocol consistency.
- Document reusable UI in Storybook by colocating a `*.stories.tsx` file beside the component or within `src/stories` following the established examples.
- Write asynchronous logic with `async/await`, wrap operations that can fail in try/catch blocks (or `useErrorHandler`) and surface friendly error messages as seen in the dashboard and builder modules.
